# Claude Code Project Information

## Project Overview
Istaroth is a pipeline for extracting, cleaning, and structuring textual content from Genshin Impact with the goal of powering a Retrieval-Augmented Generation (RAG) language model capable of answering lore questions about the world of Teyvat.

## Development Setup

### Requirements Management
This project uses uv for dependency management:
- Dependencies are declared in `pyproject.toml` (`[project.dependencies]` for app deps, `[dependency-groups]` for ml and dev deps)
- Run `uv lock` to update the lockfile (`uv.lock`)
- Run `uv sync` to install/sync dependencies into `.venv/`
- After changing dependencies, regenerate Docker export files:
  `uv export --frozen --only-group ml --no-hashes --no-emit-project > requirements-ml.txt && uv export --frozen --no-group dev --no-group ml --no-hashes --no-emit-project > requirements-app.txt`

### Code Quality
Pre-commit hooks are configured with:
- Black (code formatting)
- isort (import sorting)
- mypy (type checking)
- Standard pre-commit hooks (trailing whitespace, YAML validation, etc.)

### Commands

- Install/sync dependencies: `uv sync`
- Add app dependency: `uv add <package>`
- Add ML dependency: `uv add --group ml <package>`
- Add dev dependency: `uv add --group dev <package>`
- Update lockfile: `uv lock`
- Install pre-commit: `pre-commit install`
- Run pre-commit manually: `pre-commit run --all-files`
- Type checking: `mypy`

### Project Structure
```
istaroth/
├── istaroth/              # Main package
│   └── __init__.py
├── pyproject.toml         # Project configuration, dependencies, and tool settings
├── uv.lock                # Lockfile (managed by uv)
├── requirements-ml.txt    # Docker export: ML dependencies (generated by uv export)
├── requirements-app.txt   # Docker export: app dependencies (generated by uv export)
├── .pre-commit-config.yaml
└── README.md
```

## Project Terminology
- `<AGD>` is used to refer to a separate AnimeGameData path containing the actual data extracted from the game.

## Project Conventions
- ALWAYS use full import path starting from istaroth.
- ALWAYS run things from the root of the repo
- ALWAYS write concise commit message; use bullet points when it's helpful but don't feel obligated to include multiple bullets.

## Code Best Practices
- ALWAYS prefer inline Python scripts to temporary script files when possible.
- NEVER re-export symbols from child modules in the parent package
- ALWAYS use modern features as available in Python 3.11; DO NOT use features only in Python 3.12
- ALWAYS be strict with error handling and prefer raising exception than falling back to implicit default values
- NEVER import individual symbols from modules and ALWAYS use module-level imports only; exceptions: it is okay to import individual symbols from the typing stdlib package.
- NEVER use TYPE_CHECKING conditional imports
- Write very concise docstring; don't list all args & return values when they are self-explanatory from the function signature and names
- Use the Python walrus operation := when appropriate to simplify code
- ALWAYS prefer using features available on pathlib.Path, e.g. read_text and read_bytes
- ALWAYS use names that start with _ for symbols that are not supposed to be used outside its current module/class/etc.
- ALWAYS prefer pytests as functions, not classes
- ALWAYS prefer one-lines
- ALWAYS avoid intermediate variables that is only used once
- ALWAYS avoid writing obvious comments

## Import Conventions
- ALWAYS import istaroth.agd.types aliased as agd_types outside istaroth.agd; but import is normally as from istaroth.agd import types when inside the istaroth.agd package.
- ALWAYS use from package.subpackage import module import syntax; e.g. from istaroth.agd import processing

## Functional Programming Guidelines
- Pass arguments that are not primary inputs to the function itself but rather toolkit objects (e.g. DataRepo) as kw-only args

## Git Workflow Best Practices
- ALWAYS run precommit separately and added resulted changes before you offer to git commit

## Script Development Guidelines
- ALWAYS include a shebang and make the script executable for files under scripts/

## Running the Application

See the [Web UI section](README.md#web-ui) in the README for environment setup and how to launch the backend and frontend.

## LangSmith Tracing
The RAG pipeline supports LangSmith tracing for debugging and monitoring. Required environment variables:
- `LANGSMITH_API_KEY`: Your LangSmith API key
- `LANGSMITH_PROJECT`: Project name (e.g., "istaroth-rag")
- `LANGSMITH_TRACING`: Set to "true" to enable tracing

Optional environment variables:
- `LANGSMITH_ENDPOINT`: Custom LangSmith endpoint (defaults to https://api.smith.langchain.com)

Tracing is automatically enabled when all required environment variables are set.

## Development Conventions
- ALWAYS invoke mypy as `.venv/bin/mypy`
- ALWAYS invoke python as `.venv/bin/python` or `uv run python`
- The `.venv/` virtualenv is managed by uv; run `uv sync` to create/update it. You can source `.env` to get env vars if needed.

## Task Tracking

This project uses `bd` for task tracking.

## Landing the Plane (Session Completion)

**When ending a work session**, you MUST complete ALL steps below. Work is NOT complete until `git push` succeeds. NOTE that you should only do this after the user tells you that it's done/finished.

**MANDATORY WORKFLOW:**

1. **File issues for remaining work** - Create issues for anything that needs follow-up
2. **Run quality gates** (if code changed) - Tests, linters, builds
3. **Update issue status** - Close finished work, update in-progress items; amend existing commit to pick up the `.beads/issues.jsonl` change if needed.
4. **PUSH TO REMOTE** - This is MANDATORY:
   ```bash
   git pull --rebase
   bd sync
   git push
   git status  # MUST show "up to date with origin"
   ```
5. **Clean up** - Clear stashes, prune remote branches
6. **Verify** - All changes committed AND pushed
7. **Hand off** - Provide context for next session

**CRITICAL RULES:**
- Work is NOT complete until `git push` succeeds
- NEVER stop before pushing - that leaves work stranded locally
- NEVER say "ready to push when you are" - YOU must push
- If push fails, resolve and retry until it succeeds
